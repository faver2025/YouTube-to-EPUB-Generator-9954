// Google Gemini API Service - PRODUCTION READY
class GeminiService {
  constructor() {
    this.apiKey = import.meta.env.VITE_GEMINI_API_KEY;
    this.baseUrl = 'https://generativelanguage.googleapis.com/v1beta/models';
    this.model = 'gemini-pro';
    
    // Validate API key
    if (this.apiKey && this.apiKey !== 'your_gemini_api_key_here') {
      console.log('âœ… Gemini API configured successfully');
    } else {
      console.warn('âš ï¸ Gemini API key not configured');
    }
  }

  async generateContent(prompt, model = this.model) {
    if (!this.apiKey || this.apiKey === 'your_gemini_api_key_here') {
      throw new Error('Gemini API key not configured');
    }

    try {
      const response = await fetch(`${this.baseUrl}/${model}:generateContent?key=${this.apiKey}`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          contents: [{
            parts: [{
              text: prompt
            }]
          }],
          generationConfig: {
            temperature: 0.7,
            topK: 40,
            topP: 0.95,
            maxOutputTokens: 8192,
          },
          safetySettings: [
            {
              category: "HARM_CATEGORY_HARASSMENT",
              threshold: "BLOCK_MEDIUM_AND_ABOVE"
            },
            {
              category: "HARM_CATEGORY_HATE_SPEECH",
              threshold: "BLOCK_MEDIUM_AND_ABOVE"
            }
          ]
        })
      });

      if (!response.ok) {
        const errorData = await response.json().catch(() => ({}));
        throw new Error(`Gemini API error: ${response.status} - ${errorData.error?.message || 'Unknown error'}`);
      }

      const data = await response.json();
      
      if (!data.candidates || data.candidates.length === 0) {
        throw new Error('No content generated by Gemini API');
      }

      return data.candidates[0].content.parts[0].text;
    } catch (error) {
      console.error('Gemini API error:', error);
      throw error;
    }
  }

  async generateBookContent(videos, settings) {
    const videoSummaries = videos.map(video => `
ğŸ“¹ **${video.title}**
- ãƒãƒ£ãƒ³ãƒãƒ«: ${video.channel}
- é•·ã•: ${video.duration}
- èª¬æ˜: ${video.description?.substring(0, 300)}...
- å­—å¹•: ${video.transcript ? 'åˆ©ç”¨å¯èƒ½' : 'å­—å¹•ãªã—'}
`).join('\n');

    const prompt = `
ã‚ãªãŸã¯çµŒé¨“è±Šå¯Œãªç·¨é›†è€…å…¼ãƒ©ã‚¤ã‚¿ãƒ¼ã§ã™ã€‚ä»¥ä¸‹ã®YouTubeå‹•ç”»ã‹ã‚‰ã€èª­è€…ã«ã¨ã£ã¦ä¾¡å€¤ã®é«˜ã„é›»å­æ›¸ç±ã‚’ä½œæˆã—ã¦ãã ã•ã„ã€‚

## å‹•ç”»æƒ…å ±
${videoSummaries}

## é›»å­æ›¸ç±ã®è¨­å®š
- ç›®æ¨™æ–‡å­—æ•°: ${settings.targetLength.toLocaleString()}æ–‡å­—
- æ–‡ä½“: ${this.getToneDescription(settings.tone)}
- å¯¾è±¡èª­è€…: ä¸€èˆ¬èª­è€…
- è¨€èª: æ—¥æœ¬èª

## è¦æ±‚äº‹é …
1. å‹•ç”»ã®å†…å®¹ã‚’çµ±åˆã—ã€ä½“ç³»çš„ãªå­¦ç¿’æ›¸ç±ã‚’ä½œæˆ
2. å„ç« ã¯${Math.floor(settings.targetLength / 5).toLocaleString()}æ–‡å­—ç¨‹åº¦
3. èª­ã¿ã‚„ã™ãã€å®Ÿç”¨çš„ãªå†…å®¹ã«ã™ã‚‹
4. å…·ä½“ä¾‹ã‚„äº‹ä¾‹ã‚’è±Šå¯Œã«å«ã‚ã‚‹
5. ç« ã®æœ€å¾Œã«è¦ç‚¹ã‚’ã¾ã¨ã‚ã‚‹

## å‡ºåŠ›å½¢å¼
ä»¥ä¸‹ã®JSONå½¢å¼ã§è¿”ã—ã¦ãã ã•ã„ï¼ˆJSONã®ã¿ã€ä»–ã®ãƒ†ã‚­ã‚¹ãƒˆã¯å«ã‚ãªã„ï¼‰ï¼š

{
  "chapters": [
    {
      "id": 1,
      "title": "ç¬¬1ç« ï¼šåŸºç¤æ¦‚å¿µã®ç†è§£",
      "content": "# ç¬¬1ç« ï¼šåŸºç¤æ¦‚å¿µã®ç†è§£\\n\\n## æ¦‚è¦\\n\\nå‹•ç”»ã§èª¬æ˜ã•ã‚ŒãŸå†…å®¹ã‚’åŸºã«...ï¼ˆãƒãƒ¼ã‚¯ãƒ€ã‚¦ãƒ³å½¢å¼ã§è©³ç´°ãªå†…å®¹ï¼‰",
      "charCount": 2500
    },
    {
      "id": 2,
      "title": "ç¬¬2ç« ï¼šå®Ÿè·µçš„å¿œç”¨",
      "content": "# ç¬¬2ç« ï¼šå®Ÿè·µçš„å¿œç”¨\\n\\n## ã¯ã˜ã‚ã«\\n\\nå‰ç« ã§å­¦ã‚“ã åŸºç¤ã‚’åŸºã«...ï¼ˆãƒãƒ¼ã‚¯ãƒ€ã‚¦ãƒ³å½¢å¼ã§è©³ç´°ãªå†…å®¹ï¼‰",
      "charCount": 2800
    }
  ],
  "totalChars": ${settings.targetLength},
  "metadata": {
    "generatedAt": "${new Date().toISOString()}",
    "sourceVideos": ${videos.length},
    "tone": "${settings.tone}",
    "language": "ja",
    "aiModel": "gemini-pro"
  }
}

å¿…ãš5-6ç« ã®æ§‹æˆã§ã€å®Ÿç”¨çš„ã§èª­ã¿å¿œãˆã®ã‚ã‚‹é›»å­æ›¸ç±ã‚’ä½œæˆã—ã¦ãã ã•ã„ã€‚
`;

    try {
      const response = await this.generateContent(prompt);
      // JSONã‚’æŠ½å‡º
      const jsonMatch = response.match(/\{[\s\S]*\}/);
      if (jsonMatch) {
        const result = JSON.parse(jsonMatch[0]);
        console.log('ğŸ“š Book content generated successfully:', result.chapters.length, 'chapters');
        return result;
      }
      throw new Error('Invalid JSON format in response');
    } catch (error) {
      console.error('Book generation error:', error);
      throw error;
    }
  }

  async enhanceChapter(chapter, enhancements) {
    const enhancementDescriptions = {
      'readability': 'æ–‡ç« ã‚’èª­ã¿ã‚„ã™ãã€ç†è§£ã—ã‚„ã™ã„å½¢ã«æ”¹å–„ã™ã‚‹',
      'examples': 'å…·ä½“ä¾‹ã€å®Ÿä¾‹ã€äº‹ä¾‹ç ”ç©¶ã‚’è¿½åŠ ã™ã‚‹',
      'structure': 'è¦‹å‡ºã—æ§‹é€ ã‚’æœ€é©åŒ–ã—ã€è«–ç†çš„ãªæµã‚Œã‚’æ”¹å–„ã™ã‚‹',
      'engagement': 'èª­è€…ã®èˆˆå‘³ã‚’å¼•ãè¦ç´ ï¼ˆè³ªå•ã€ãƒãƒ£ãƒ¬ãƒ³ã‚¸ã€ã‚³ãƒ©ãƒ ï¼‰ã‚’è¿½åŠ ã™ã‚‹',
      'seo': 'æ¤œç´¢ã‚¨ãƒ³ã‚¸ãƒ³ã«æœ€é©åŒ–ã•ã‚ŒãŸã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ã‚’è‡ªç„¶ã«çµ„ã¿è¾¼ã‚€',
      'formatting': 'ãƒªã‚¹ãƒˆã€è¡¨ã€å¼·èª¿ã€å¼•ç”¨ãªã©ã®è¦–è¦šçš„è¦ç´ ã‚’è¿½åŠ ã™ã‚‹'
    };

    const selectedEnhancements = enhancements
      .map(id => enhancementDescriptions[id])
      .filter(Boolean);

    const prompt = `
ä»¥ä¸‹ã®ç« ã‚’æŒ‡å®šã•ã‚ŒãŸæ”¹å–„é …ç›®ã«åŸºã¥ã„ã¦å¼·åŒ–ã—ã¦ãã ã•ã„ã€‚

## ç¾åœ¨ã®ç« 
**ã‚¿ã‚¤ãƒˆãƒ«:** ${chapter.title}
**å†…å®¹:**
${chapter.content}

## æ”¹å–„é …ç›®
${selectedEnhancements.map((desc, index) => `${index + 1}. ${desc}`).join('\n')}

## è¦æ±‚äº‹é …
- å…ƒã®å†…å®¹ã®æ„å‘³ã‚’æãªã‚ãšã«æ”¹å–„ã™ã‚‹
- æ”¹å–„å¾Œã‚‚è‡ªç„¶ã§èª­ã¿ã‚„ã™ã„æ–‡ç« ã«ã™ã‚‹
- æ–‡å­—æ•°ã¯å…ƒã®1.2-1.5å€ç¨‹åº¦ã«å¢—ã‚„ã™
- ãƒãƒ¼ã‚¯ãƒ€ã‚¦ãƒ³å½¢å¼ã‚’ç¶­æŒã™ã‚‹

## å‡ºåŠ›å½¢å¼
ä»¥ä¸‹ã®JSONå½¢å¼ã§è¿”ã—ã¦ãã ã•ã„ï¼ˆJSONã®ã¿ï¼‰ï¼š

{
  "id": ${chapter.id},
  "title": "${chapter.title}",
  "content": "æ”¹å–„å¾Œã®å†…å®¹ï¼ˆãƒãƒ¼ã‚¯ãƒ€ã‚¦ãƒ³å½¢å¼ï¼‰",
  "charCount": æ”¹å–„å¾Œã®æ–‡å­—æ•°,
  "lastEnhanced": "${new Date().toISOString()}",
  "appliedEnhancements": ${JSON.stringify(enhancements)},
  "enhancementSummary": "ã©ã®ã‚ˆã†ãªæ”¹å–„ã‚’è¡Œã£ãŸã‹ã®ç°¡æ½”ãªèª¬æ˜"
}
`;

    try {
      const response = await this.generateContent(prompt);
      const jsonMatch = response.match(/\{[\s\S]*\}/);
      if (jsonMatch) {
        const result = JSON.parse(jsonMatch[0]);
        console.log('âœ¨ Chapter enhanced successfully:', result.enhancementSummary);
        return result;
      }
      throw new Error('Invalid JSON format in response');
    } catch (error) {
      console.error('Chapter enhancement error:', error);
      throw error;
    }
  }

  async generateSegment(chapterTitle, existingContent, wordCount = 1000) {
    const prompt = `
ä»¥ä¸‹ã®ç« ã«æ–°ã—ã„ã‚»ã‚°ãƒ¡ãƒ³ãƒˆã‚’è¿½åŠ ã—ã¦ãã ã•ã„ã€‚

## ç« æƒ…å ±
**ã‚¿ã‚¤ãƒˆãƒ«:** ${chapterTitle}
**æ—¢å­˜ã®å†…å®¹:**
${existingContent.substring(0, 1500)}...

## è¦æ±‚äº‹é …
- ${wordCount}æ–‡å­—ç¨‹åº¦ã®æ–°ã—ã„ã‚»ã‚°ãƒ¡ãƒ³ãƒˆã‚’ä½œæˆ
- æ—¢å­˜å†…å®¹ã¨è‡ªç„¶ã«ç¹‹ãŒã‚‹å†…å®¹
- èª­è€…ã«ã¨ã£ã¦ä¾¡å€¤ã®ã‚ã‚‹è¿½åŠ æƒ…å ±
- å…·ä½“ä¾‹ã‚„å®Ÿè·µçš„ãªã‚¢ãƒ‰ãƒã‚¤ã‚¹ã‚’å«ã‚ã‚‹
- ãƒãƒ¼ã‚¯ãƒ€ã‚¦ãƒ³å½¢å¼ã§è¨˜è¿°

## å‡ºåŠ›å½¢å¼
ä»¥ä¸‹ã®JSONå½¢å¼ã§è¿”ã—ã¦ãã ã•ã„ï¼ˆJSONã®ã¿ï¼‰ï¼š

{
  "content": "\\n\\n## AIè¿½åŠ ã‚»ã‚°ãƒ¡ãƒ³ãƒˆ\\n\\næ–°ã—ã„ã‚»ã‚°ãƒ¡ãƒ³ãƒˆã®å†…å®¹...",
  "charCount": ${wordCount},
  "generatedAt": "${new Date().toISOString()}",
  "segmentType": "å®Ÿè·µçš„å¿œç”¨" ã¾ãŸã¯ "è©³ç´°è§£èª¬" ã¾ãŸã¯ "äº‹ä¾‹ç ”ç©¶"
}
`;

    try {
      const response = await this.generateContent(prompt);
      const jsonMatch = response.match(/\{[\s\S]*\}/);
      if (jsonMatch) {
        const result = JSON.parse(jsonMatch[0]);
        console.log('ğŸ”§ Segment generated successfully:', result.segmentType);
        return result;
      }
      throw new Error('Invalid JSON format in response');
    } catch (error) {
      console.error('Segment generation error:', error);
      throw error;
    }
  }

  async chatResponse(message, context) {
    const prompt = `
ã‚ãªãŸã¯é›»å­æ›¸ç±ä½œæˆã®å°‚é–€AIã‚¢ã‚·ã‚¹ã‚¿ãƒ³ãƒˆã§ã™ã€‚è¦ªã—ã¿ã‚„ã™ãã€å®Ÿç”¨çš„ãªã‚¢ãƒ‰ãƒã‚¤ã‚¹ã‚’æä¾›ã—ã¦ãã ã•ã„ã€‚

## ç¾åœ¨ã®ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆæƒ…å ±
- ã‚¿ã‚¤ãƒˆãƒ«: ${context.project?.title || 'æœªè¨­å®š'}
- ç« æ•°: ${context.chapters?.length || 0}ç« 
- ç·æ–‡å­—æ•°: ${context.project?.totalChars?.toLocaleString() || 0}æ–‡å­—
- é€²æ—çŠ¶æ³: ${this.getProgressStatus(context)}

## ãƒ¦ãƒ¼ã‚¶ãƒ¼ã®è³ªå•
${message}

## å›ç­”ã®è¦ä»¶
- å…·ä½“çš„ã§å®Ÿè¡Œå¯èƒ½ãªã‚¢ãƒ‰ãƒã‚¤ã‚¹ã‚’æä¾›
- é›»å­æ›¸ç±ã®å“è³ªå‘ä¸Šã«å½¹ç«‹ã¤æƒ…å ±
- è¦ªã—ã¿ã‚„ã™ã„å£èª¿ã§å›ç­”
- å¿…è¦ã«å¿œã˜ã¦å…·ä½“çš„ãªã‚¹ãƒ†ãƒƒãƒ—ã‚’æç¤º
- 500æ–‡å­—ç¨‹åº¦ã§ã¾ã¨ã‚ã‚‹

é›»å­æ›¸ç±ã®æ”¹å–„ã‚„ä½œæˆã«é–¢ã™ã‚‹å°‚é–€çš„ãªã‚¢ãƒ‰ãƒã‚¤ã‚¹ã‚’æ—¥æœ¬èªã§æä¾›ã—ã¦ãã ã•ã„ã€‚
`;

    try {
      const response = await this.generateContent(prompt);
      console.log('ğŸ’¬ AI assistant response generated');
      return {
        response: response,
        timestamp: new Date().toISOString()
      };
    } catch (error) {
      console.error('Chat response error:', error);
      throw error;
    }
  }

  getToneDescription(tone) {
    const descriptions = {
      'formal': 'ãƒ•ã‚©ãƒ¼ãƒãƒ«ã§ä¸å¯§ãªæ•¬èªèª¿',
      'casual': 'è¦ªã—ã¿ã‚„ã™ã„ã‚«ã‚¸ãƒ¥ã‚¢ãƒ«èª¿',
      'academic': 'å­¦è¡“çš„ã§è«–ç†çš„ãªæ–‡ä½“',
      'narrative': 'ç‰©èªé¢¨ã§èª­ã¿ã‚„ã™ã„æ–‡ä½“'
    };
    return descriptions[tone] || 'ãƒãƒ©ãƒ³ã‚¹ã®å–ã‚ŒãŸæ–‡ä½“';
  }

  getProgressStatus(context) {
    if (!context.project) return 'æ–°è¦ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆ';
    if (context.project.status === 'completed') return 'å®Œæˆæ¸ˆã¿';
    if (context.project.status === 'processing') return 'ç”Ÿæˆä¸­';
    return 'ç·¨é›†ä¸­';
  }
}

export const geminiService = new GeminiService();
export default geminiService;