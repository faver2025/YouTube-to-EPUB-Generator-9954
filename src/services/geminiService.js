// Google Gemini API Service - PRODUCTION READY
class GeminiService {
  constructor() {
    this.apiKey = import.meta.env.VITE_GEMINI_API_KEY;
    this.baseUrl = 'https://generativelanguage.googleapis.com/v1beta/models';
    this.model = 'gemini-pro';
    
    // Validate API key
    if (this.apiKey && this.apiKey !== 'your_gemini_api_key_here') {
      console.log('✅ Gemini API configured successfully');
    } else {
      console.warn('⚠️ Gemini API key not configured');
    }
  }

  async generateContent(prompt, model = this.model) {
    if (!this.apiKey || this.apiKey === 'your_gemini_api_key_here') {
      throw new Error('Gemini API key not configured');
    }

    try {
      const response = await fetch(`${this.baseUrl}/${model}:generateContent?key=${this.apiKey}`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          contents: [{
            parts: [{
              text: prompt
            }]
          }],
          generationConfig: {
            temperature: 0.7,
            topK: 40,
            topP: 0.95,
            maxOutputTokens: 8192,
          },
          safetySettings: [
            {
              category: "HARM_CATEGORY_HARASSMENT",
              threshold: "BLOCK_MEDIUM_AND_ABOVE"
            },
            {
              category: "HARM_CATEGORY_HATE_SPEECH",
              threshold: "BLOCK_MEDIUM_AND_ABOVE"
            }
          ]
        })
      });

      if (!response.ok) {
        const errorData = await response.json().catch(() => ({}));
        throw new Error(`Gemini API error: ${response.status} - ${errorData.error?.message || 'Unknown error'}`);
      }

      const data = await response.json();
      
      if (!data.candidates || data.candidates.length === 0) {
        throw new Error('No content generated by Gemini API');
      }

      return data.candidates[0].content.parts[0].text;
    } catch (error) {
      console.error('Gemini API error:', error);
      throw error;
    }
  }

  async generateBookContent(videos, settings) {
    const videoSummaries = videos.map(video => `
📹 **${video.title}**
- チャンネル: ${video.channel}
- 長さ: ${video.duration}
- 説明: ${video.description?.substring(0, 300)}...
- 字幕: ${video.transcript ? '利用可能' : '字幕なし'}
`).join('\n');

    const prompt = `
あなたは経験豊富な編集者兼ライターです。以下のYouTube動画から、読者にとって価値の高い電子書籍を作成してください。

## 動画情報
${videoSummaries}

## 電子書籍の設定
- 目標文字数: ${settings.targetLength.toLocaleString()}文字
- 文体: ${this.getToneDescription(settings.tone)}
- 対象読者: 一般読者
- 言語: 日本語

## 要求事項
1. 動画の内容を統合し、体系的な学習書籍を作成
2. 各章は${Math.floor(settings.targetLength / 5).toLocaleString()}文字程度
3. 読みやすく、実用的な内容にする
4. 具体例や事例を豊富に含める
5. 章の最後に要点をまとめる

## 出力形式
以下のJSON形式で返してください（JSONのみ、他のテキストは含めない）：

{
  "chapters": [
    {
      "id": 1,
      "title": "第1章：基礎概念の理解",
      "content": "# 第1章：基礎概念の理解\\n\\n## 概要\\n\\n動画で説明された内容を基に...（マークダウン形式で詳細な内容）",
      "charCount": 2500
    },
    {
      "id": 2,
      "title": "第2章：実践的応用",
      "content": "# 第2章：実践的応用\\n\\n## はじめに\\n\\n前章で学んだ基礎を基に...（マークダウン形式で詳細な内容）",
      "charCount": 2800
    }
  ],
  "totalChars": ${settings.targetLength},
  "metadata": {
    "generatedAt": "${new Date().toISOString()}",
    "sourceVideos": ${videos.length},
    "tone": "${settings.tone}",
    "language": "ja",
    "aiModel": "gemini-pro"
  }
}

必ず5-6章の構成で、実用的で読み応えのある電子書籍を作成してください。
`;

    try {
      const response = await this.generateContent(prompt);
      // JSONを抽出
      const jsonMatch = response.match(/\{[\s\S]*\}/);
      if (jsonMatch) {
        const result = JSON.parse(jsonMatch[0]);
        console.log('📚 Book content generated successfully:', result.chapters.length, 'chapters');
        return result;
      }
      throw new Error('Invalid JSON format in response');
    } catch (error) {
      console.error('Book generation error:', error);
      throw error;
    }
  }

  async enhanceChapter(chapter, enhancements) {
    const enhancementDescriptions = {
      'readability': '文章を読みやすく、理解しやすい形に改善する',
      'examples': '具体例、実例、事例研究を追加する',
      'structure': '見出し構造を最適化し、論理的な流れを改善する',
      'engagement': '読者の興味を引く要素（質問、チャレンジ、コラム）を追加する',
      'seo': '検索エンジンに最適化されたキーワードを自然に組み込む',
      'formatting': 'リスト、表、強調、引用などの視覚的要素を追加する'
    };

    const selectedEnhancements = enhancements
      .map(id => enhancementDescriptions[id])
      .filter(Boolean);

    const prompt = `
以下の章を指定された改善項目に基づいて強化してください。

## 現在の章
**タイトル:** ${chapter.title}
**内容:**
${chapter.content}

## 改善項目
${selectedEnhancements.map((desc, index) => `${index + 1}. ${desc}`).join('\n')}

## 要求事項
- 元の内容の意味を損なわずに改善する
- 改善後も自然で読みやすい文章にする
- 文字数は元の1.2-1.5倍程度に増やす
- マークダウン形式を維持する

## 出力形式
以下のJSON形式で返してください（JSONのみ）：

{
  "id": ${chapter.id},
  "title": "${chapter.title}",
  "content": "改善後の内容（マークダウン形式）",
  "charCount": 改善後の文字数,
  "lastEnhanced": "${new Date().toISOString()}",
  "appliedEnhancements": ${JSON.stringify(enhancements)},
  "enhancementSummary": "どのような改善を行ったかの簡潔な説明"
}
`;

    try {
      const response = await this.generateContent(prompt);
      const jsonMatch = response.match(/\{[\s\S]*\}/);
      if (jsonMatch) {
        const result = JSON.parse(jsonMatch[0]);
        console.log('✨ Chapter enhanced successfully:', result.enhancementSummary);
        return result;
      }
      throw new Error('Invalid JSON format in response');
    } catch (error) {
      console.error('Chapter enhancement error:', error);
      throw error;
    }
  }

  async generateSegment(chapterTitle, existingContent, wordCount = 1000) {
    const prompt = `
以下の章に新しいセグメントを追加してください。

## 章情報
**タイトル:** ${chapterTitle}
**既存の内容:**
${existingContent.substring(0, 1500)}...

## 要求事項
- ${wordCount}文字程度の新しいセグメントを作成
- 既存内容と自然に繋がる内容
- 読者にとって価値のある追加情報
- 具体例や実践的なアドバイスを含める
- マークダウン形式で記述

## 出力形式
以下のJSON形式で返してください（JSONのみ）：

{
  "content": "\\n\\n## AI追加セグメント\\n\\n新しいセグメントの内容...",
  "charCount": ${wordCount},
  "generatedAt": "${new Date().toISOString()}",
  "segmentType": "実践的応用" または "詳細解説" または "事例研究"
}
`;

    try {
      const response = await this.generateContent(prompt);
      const jsonMatch = response.match(/\{[\s\S]*\}/);
      if (jsonMatch) {
        const result = JSON.parse(jsonMatch[0]);
        console.log('🔧 Segment generated successfully:', result.segmentType);
        return result;
      }
      throw new Error('Invalid JSON format in response');
    } catch (error) {
      console.error('Segment generation error:', error);
      throw error;
    }
  }

  async chatResponse(message, context) {
    const prompt = `
あなたは電子書籍作成の専門AIアシスタントです。親しみやすく、実用的なアドバイスを提供してください。

## 現在のプロジェクト情報
- タイトル: ${context.project?.title || '未設定'}
- 章数: ${context.chapters?.length || 0}章
- 総文字数: ${context.project?.totalChars?.toLocaleString() || 0}文字
- 進捗状況: ${this.getProgressStatus(context)}

## ユーザーの質問
${message}

## 回答の要件
- 具体的で実行可能なアドバイスを提供
- 電子書籍の品質向上に役立つ情報
- 親しみやすい口調で回答
- 必要に応じて具体的なステップを提示
- 500文字程度でまとめる

電子書籍の改善や作成に関する専門的なアドバイスを日本語で提供してください。
`;

    try {
      const response = await this.generateContent(prompt);
      console.log('💬 AI assistant response generated');
      return {
        response: response,
        timestamp: new Date().toISOString()
      };
    } catch (error) {
      console.error('Chat response error:', error);
      throw error;
    }
  }

  getToneDescription(tone) {
    const descriptions = {
      'formal': 'フォーマルで丁寧な敬語調',
      'casual': '親しみやすいカジュアル調',
      'academic': '学術的で論理的な文体',
      'narrative': '物語風で読みやすい文体'
    };
    return descriptions[tone] || 'バランスの取れた文体';
  }

  getProgressStatus(context) {
    if (!context.project) return '新規プロジェクト';
    if (context.project.status === 'completed') return '完成済み';
    if (context.project.status === 'processing') return '生成中';
    return '編集中';
  }
}

export const geminiService = new GeminiService();
export default geminiService;